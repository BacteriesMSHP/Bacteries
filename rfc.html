<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Request For Comments</title>
		<style>
			a {
				color: #000000;
			}
		</style>
	</head>
	<body>
		<div class="rfc" id="0001">
		<h3><a href="#0001">RFC #0001 - Стиль кода</a></h3>
		Функции и переменные называются в стиле lowerCamelCase.<br>
		Классы называются в стиле UpperCamelCase.<br>
		Глобальные константы называются КАПСЛОКОМ_ЧЕРЕЗ_ПОДЧЁРКИВАНИЕ.<br>
		Функции-геттеры называются getSmth()<br>
		Функции-сеттеры называются setSmth()<br>
		Мы не используем венгерскую нотацию, т. е. имя переменной не содержит указания на её тип.<br>
		Заголовочные файлы имеют расширение .hpp, а не .h<br>
		В заголовочных файлах используем include-guard, а не pragma once, т.е. пишем так:<br>
		#ifndef SOMEFILE_HPP<br>
		#define SOMEFILE_HPP<br>
		// Code<br>
		#endif<br>
		В заголовочных файлах не пишем #include'ов, если необходимо использовать название класса пишем<br>
		class Smth;<br>
		в начале кода.<br>
		private-часть объявляем в явном виде.<br>
		Если необходимо использовать cin, cout etc пишем using namespace std;<br>
		private, public и protected пишем без отступа от слова class.<br>
		Фигурные скобочки ставим так:<br>
		if (...) {<br>
		...<br>
		} else {<br>
		...<br>
		}<br>
		Табуляцию делаем 4 пробелами (это не лучший вариант, но правильный мы сейчас не потянем), на конце файла должна стоять новая строка. Конец строки, если это настраивается в редакторе, делаем в Unix-style (LF а не CRLF).<br>
		Множественные константы (типа side) делаем с помощью enum class'ов, именуя сам enum class и его элементы как классы:<br>
		enum class Side { SideLeft, SideRight, SideBack, SideForward, SideRandom };<br>
		Непосредственно enum не используем никогда.<br>
		В прототипе функции пишем только название типа аргумента, т. е.:<br>
		void setWeight(int)<br>
		Всегда явно указываем this-&gt;, даже когда это не необходимо.<br>
		</div>
		<div class="rfc" id="0002">
		<h3><a href="#0002">RFC #0002 - класс Command</a></h3>
		Класс Comand содержит метод do(), который принимает в качестве аргумента мир, и координаты бактерии, флаг isPseudo, который показывает является ли действия завершающим ход и всё, вообще всё.<br>
		Почему этого достаточно: бактерия, которую можно однозначно получить по миру и координатам содержит в себе номер строчки кода, необходимый для различных jump'ов, очевидно таким образом можно покормить бактерию через setWeight(), передвинуть её по миру, найти бактерию для удара, убить её.
		</div>
		<div class="rfc" id="0003">
			<h3><a href="#0003">RFC #0003 - enum class Side</a></h3>
			В файле bactery.hpp содержится<br>
			enum class Side { SideLeft, SideRight, SideBack, SideForward, SideRandom };<br>
			Его следует использовать для любых "сторон". SideRandom не должен быть состоянием объекта, т. е. когда чему-либо присваивается SideRandom он должен быть сразу изменён на какой-либо из других Side*.
		</div>
		<div class="rfc" id="0004">
			<h3><a href="#0004">RFC #0004 - класс Bactery</a></h3>
			Класс Bactery содержит поля:<br>
			Side turnSide; // Сторона, в которую повёрнута бактерия<br>
			int weight; // Вес бактерии<br>
			int lineNumber; // Номер строки кода, на которой находится бактерия<br>
			Для всех этих полей установлены сеттеры-геттеры согласно <a href="#0001">RFC #0001</a>.<br>
			У класса Bactery есть три конструктора. Конструктор по умолчанию инициализирует вес и сторону значениями BACTERY_DEFAULT_WEIGHT и BACTERY_DEFAULT_SIDE, определёнными в bacyery.hpp. lineNumber устанавливается в 1. Также определены конструкторы, принимающие (weight, turnSide) (lineNumber устанавливается в 1) и (weight, turnSide, lineNumber).<br>
			Определён приватный метод turn(), который заменяет SideRandom на случайную сторону согласно <a href="#0003">RFC #0003</a>.
		</div>
	</body>
</html>

