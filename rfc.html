<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Request For Comments</title>
		<style>
			a {
				color: #000000;
			}
		</style>
	</head>
	<body>
		<div class="rfc" id="0001">
		<h3><a href="#0001">RFC #0001 - Стиль кода</a></h3>
		Функции и переменные называются в стиле lowerCamelCase.<br>
		Классы называются в стиле UpperCamelCase.<br>
		Глобальные константы называются КАПСЛОКОМ_ЧЕРЕЗ_ПОДЧЁРКИВАНИЕ.<br>
		Функции-геттеры называются getSmth()<br>
		Функции-сеттеры называются setSmth()<br>
		Мы не используем венгерскую нотацию, т. е. имя переменной не содержит указания на её тип.<br>
		Заголовочные файлы имеют расширение .hpp, а не .h<br>
		В заголовочных файлах используем include-guard, а не pragma once, т.е. пишем так:<br>
		#ifndef SOMEFILE_HPP<br>
		#define SOMEFILE_HPP<br>
		// Code<br>
		#endif<br>
		В заголовочных файлах не пишем #include'ов, если необходимо использовать название класса пишем<br>
		class Smth;<br>
		в начале кода.<br>
		private-часть объявляем в явном виде.<br>
		Если необходимо использовать cin, cout etc пишем using namespace std;<br>
		private, public и protected пишем без отступа от слова class.<br>
		Фигурные скобочки ставим так:<br>
		if (...) {<br>
		...<br>
		} else {<br>
		...<br>
		}<br>
		Табуляцию делаем 4 пробелами (это не лучший вариант, но правильный мы сейчас не потянем), на конце файла должна стоять новая строка. Конец строки, если это настраивается в редакторе, делаем в Unix-style (LF а не CRLF).<br>
		Множественные константы (типа side) делаем с помощью enum class'ов, именуя сам enum class и его элементы как классы:<br>
		enum class Side { Left, Right, Back, Forward, Random };<br>
		Непосредственно enum не используем никогда.<br>
		В прототипе функции пишем только название типа аргумента, т. е.:<br>
		void setWeight(int)<br>
		Всегда явно указываем this-&gt;, даже когда это не необходимо.<br>
		</div>
		<div class="rfc" id="0002">
		<h3><a href="#0002">RFC #0002 - класс Command</a></h3>
            Класс Command содержит метод do(), который принимает в качестве аргумента мир, и координаты бактерии, флаг isPseudo, который показывает является ли действия завершающим ход и всё, вообще всё.<br>
            Почему этого достаточно: бактерия, которую можно однозначно получить по миру и координатам содержит в себе номер строчки кода, необходимый для различных jump'ов, очевидно таким образом можно покормить бактерию через setWeight(), передвинуть её по миру, найти бактерию для удара, убить её.<br>
		</div>
		<div class="rfc" id="0003">
			<h3><a href="#0003">RFC #0003 - enum class Side</a></h3>
			В файле bactery.hpp содержится<br>
			enum class Side { Left, Right, Back, Forward, Random };<br>
			Его следует использовать для любых "сторон". Side::Random не должен быть состоянием объекта, т. е. когда чему-либо присваивается SideRandom он должен быть сразу изменён на какой-либо из других Side*.
		</div>
		<div class="rfc" id="0004">
			<h3><a href="#0004">RFC #0004 - класс Bactery</a></h3>
			Класс Bactery содержит поля:<br>
            League *parent; // указатель на лигу, к которой принадлежит бактерия(Для того чтобы определять, команды какой лиги исполнять)<br>
			Side turnSide; // Сторона, в которую повёрнута бактерия<br>
			int weight; // Вес бактерии<br>
			int lineNumber; // Номер строки кода, на которой находится бактерия<br>
			Для всех этих полей установлены сеттеры-геттеры согласно <a href="#0001">RFC #0001</a>.<br>
			У класса Bactery есть один конструктор. Он принимает (parent, weight, turnSide, lineNumber), где последние 3 параметра - необязательные. weight и turnSide автоматически устанавливаются соответственно константам в bactery.hpp, lineNumber в 1.<br>
			Определён приватный метод turn(), который заменяет SideRandom на случайную сторону согласно <a href="#0003">RFC #0003</a>.
            Также необходим метод step(), который будет выполнять и изменять lineNumber, пока клетка не погибнет или не сделает полноценное действие.<br>
		</div>

		<div class="rfc" id="0005">
			<h3><a href="#0005">RFC #0005 - класс League</a></h3>
        Класс League содержит поля:<br>
				vector<Bactery*> bacteries; // массив указателей клеток лиги<br>
				vector<Command> commands; // массив комманд клеток этой лиги<br>
                Interpreter* interpreter;// указатель на интерпритатор ибо надо это для удаления и добавления клеток<br>
				Конструктор: принимает на вход имя файла интеллекта(по которому генерит массив комманд) и указатель на интерпретатор	<br>
			Публичные методы:<br>
                deleteBactery(Bactery*) // удаляет клетку по передаваемому указателю<br>
				addBactery(Bactery*) // добвляет указатель на бактерию в массив bacteries<br>
				steps() // выполняет метод step() каждой клетки<br>
		</div>
		<div class="rfc" id="0006">
			<h3><a href="#0006">RFC #0006 - класс Interpreter</a></h3>
        Класс Interpreter содержит поля:<br>
		Приватные методы:<br>
		        Bactery* world[WORLD_SIZE][WORLD_SIZE] - двумерный массив поля, в котором двигаются наши бактерии, где WORLD_SIZE - размер поля, по умолчанию = 20(это еще нужно обсудить)<br>
		        vector <League> leagues; //Массив рас<br>
        Публичные методы:<br>
                Конструктор: принимает на вход массив строк с именами файлов каждой лиги бактерий<br>    
                act(); // метод выполняющий steps() для каждой лиги<br>
                Bactery* getWorldItem(int x, int y) - возвращает ссылку на бактерию в x, y<br>    
				void setWorldItem(int x, int y, Bactery* bact) - ДОГАДАЙТЕСЬ БЛИН
		</div>

	</body>
</html>
