<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Request For Comments</title>
		<style>
			a {
				color: #000000;
			}
		</style>
	</head>
	<body>
		<div class="rfc" id="0001">
		<h3><a href="#0001">RFC #0001 - Стиль кода</a></h3>
		Функции и переменные называются в стиле lowerCamelCase.<br>
		Классы называются в стиле UpperCamelCase.<br>
		Глобальные константы называются КАПСЛОКОМ_ЧЕРЕЗ_ПОДЧЁРКИВАНИЕ.<br>
		Функции-геттеры называются getSmth()<br>
		Функции-сеттеры называются setSmth()<br>
		Мы не используем венгерскую нотацию, т. е. имя переменной не содержит указания на её тип.<br>
		Заголовочные файлы имеют расширение .hpp, а не .h<br>
		В заголовочных файлах используем include-guard, а не pragma once, т.е. пишем так:<br>
		#ifndef SOMEFILE_HPP<br>
		#define SOMEFILE_HPP<br>
		// Code<br>
		#endif<br>
		В заголовочных файлах не пишем #include'ов, если необходимо использовать название класса пишем<br>
		class Smth;<br>
		в начале кода.<br>
		private-часть объявляем в явном виде.<br>
		Если необходимо использовать cin, cout etc пишем using namespace std;<br>
		private, public и protected пишем без отступа от слова class.<br>
		Фигурные скобочки ставим так:<br>
		if (...) {<br>
		...<br>
		} else {<br>
		...<br>
		}<br>
		Табуляцию делаем 4 пробелами (это не лучший вариант, но правильный мы сейчас не потянем), на конце файла должна стоять новая строка. Конец строки, если это настраивается в редакторе, делаем в Unix-style (LF а не CRLF).<br>
		Множественные константы (типа side) делаем с помощью enum class'ов, именуя сам enum class и его элементы как классы:<br>
		enum class Side { Left, Right, Back, Forward, Random };<br>
		Непосредственно enum не используем никогда.<br>
		В прототипе функции пишем только название типа аргумента, т. е.:<br>
		void setWeight(int)<br>
		Всегда явно указываем this-&gt;, даже когда это не необходимо.<br>
		</div>
		<div class="rfc" id="0002">
		<h3><a href="#0002">RFC #0002 - класс Command</a></h3>
        private:<br>
            bool Is_Pseudo; // Говорит о том, полноценное это действие(false) или нет (true)<br>
            int Index_command; // Индекс функции в глобальном массиве(в котором прописаны все возможные функции(впоследствии и DLC))<br>
            League* parent; //Для добавления/удаления бактерий<br>
        public:<br>
            Конструктор: принимает на вход: флаг полноценности, индекс функции в глобальном массиве, и указатель на League
            act(Baktery*); // Метод который исполняет функцию из глобального массива на переданной Baktery (аналог методу do())<br>
		/*Класс Command содержит метод do(), который принимает в качестве аргумента мир(Указатель есть в лиге), и координаты бактерии(не нужны так, как есть указатель на бактерию и начало мира, поэтому можно определить координаты), флаг isPseudo, который показывает является ли действия завершающим ход(Есть как поле) и всё, вообще всё.<br>
		Почему этого достаточно: бактерия, которую можно однозначно получить по миру и координатам содержит в себе номер строчки кода, необходимый для различных jump'ов, очевидно таким образом можно покормить бактерию через setWeight(), передвинуть её по миру, найти бактерию для удара, убить её.*/
		</div>
		<div class="rfc" id="0003">
			<h3><a href="#0003">RFC #0003 - enum class Side</a></h3>
			В файле bactery.hpp содержится<br>
			enum class Side { Left, Right, Back, Forward, Random };<br>
			Его следует использовать для любых "сторон". Side::Random не должен быть состоянием объекта, т. е. когда чему-либо присваивается SideRandom он должен быть сразу изменён на какой-либо из других Side*.
		</div>
		<div class="rfc" id="0004">
			<h3><a href="#0004">RFC #0004 - класс Bactery</a></h3>
			Класс Bactery содержит поля:<br>
            League *parent; // указатель на лигу, к которой принадлежит бактерия(Для того чтобы определять, команды какой лиги исполнять)<br>
			Side turnSide; // Сторона, в которую повёрнута бактерия<br>
			int weight; // Вес бактерии<br>
			int lineNumber; // Номер строки кода, на которой находится бактерия<br>
			Для всех этих полей установлены сеттеры-геттеры согласно <a href="#0001">RFC #0001</a>.<br>
			У класса Bactery есть один конструктор. Он принимает (parent, weight, turnSide, lineNumber), где последние 3 параметра - необязательные. weight и turnSide автоматически устанавливаются соответственно константам в bactery.hpp, lineNumber в 1.<br>
			Определён приватный метод turn(), который заменяет SideRandom на случайную сторону согласно <a href="#0003">RFC #0003</a>.
            Также необходим метод step(), который будет выполнять и изменять lineNumber, пока не погибнет или не сделает полноценное действие.<br>
		</div>

		<div class="rfc" id="0005">
			<h3><a href="#0005">RFC #0005 - класс League</a></h3>
        Класс League содержит поля:<br>
				vector<Bactery*> bacteries; // массив указателей клеток лиги<br>
				vector<Command> commands; // массив комманд клеток этой лиги<br>
                Interpreter* interpreter;// указатель на интерпритатор ибо надо это для удаления и добавления клеток<br>
				Конструктор: принимает на вход массив команд(???возможно его стоит генерить по файлу интеллекта бактерии???) и ссылку на интерпритатор	<br>
				Публичные методы:<br>
                deleteBactery(Bactery*) // удаляет клетку по передаваемому указателю<br>
				addBactery(Bactery*) // добвляет указатель на бактерию в массив bacteries<br>
				steps() // выполняет метод step() каждой клетки<br>
		</div>
		<div class="rfc" id="0006">
			<h3><a href="#0006">RFC #0006 - класс Interpriter</a></h3>
        Класс Interpriter содержит поля:<br>
		Приватные методы:<br>
		        Bactery* world[WORLD_SIZE][WORLD_SIZE] - двумерный массив поля, в котором двигаются наши бактерии, где WORLD_SIZE - размер поля, по умолчанию = 20(это еще нужно обсудить)<br>
		        vector <Leaque> leaques; //Массив рас<br>
        Публичные методы:<br>
                Конструктор: принимает на вход массив строк с именами файлов каждой лиги бактерий
		        Конструктор: принимает на вход команду?!(не понял, зачем?)<br>    
                act(); // метод выполняющий steps() для каждой лиги и выводящий на экран получившееся поле(то есть вызывает метод?)<br>
                Bactery*[][] &getWorld()- функция, которая будет выводить на экран наше поле(Зачем возвращать ссылку на указатель, который указывает на мир?)<br>
                draw_bactery() - рисует нашу бактерию на поле с заранее заданными в ее классе: цветом?!, формой(символ?!),можно придумать и что-либо еще<br>
                actions() - скорее бесполезная функции, нужная лишь для проверки работоспособности нашего творения, но все же она выводит на экран текущюю команду,которую выполняет наша бактерия в данный момент, при этом затирая предидущую(возможно ли это нарисовать без эпилептических мерцаний поля?) <br>
                    
		</div>

	</body>
</html>
